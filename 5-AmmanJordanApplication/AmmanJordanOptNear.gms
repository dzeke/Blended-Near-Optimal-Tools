$Title Near-Optimal Utility Shortage Management Model Base
$inlinecom { }
$Ontext
   Two-stage probabilistic optimization program to identify optimal
   (lowest expected cost) mix of integrated
   short- and long-term water conservation and supply expansion management
   actions. Actions must meet a probablistic range of shortage events.

   Also identifies bounding extents for each unfixed decision variable and enumerates all
   integer alterantives within the specified near-optimal tolerance of the optimal objective function value.
   Does this by running in RunMode 4:

         RunMode 1:  Solve for the optimal solution (within near-optimal tolerance)
         RunMode 2:  Solve for the optimal solution and minimum as well as maximum extents of unfixed variables
               IGNORED in this file -- RunMode 3:  Solve the maximum extents of each variable unfixing the current variable if it is fixed
         RunMode 4:  1, 2, and all near-optimal integer alternatives using an Enumeration algorithm for decision variables

        The near-optimal formulation is the original model formulation:

               Minimize Z = f(x)
               subject to Ax <= b
               with the added constraint
                   f(x) <= gamma*Zopt

              where Z=the objective function value, x=vector of decision variables, f(x) is the objective function, A and b define a maxtrix of the original constraints,
              gamma is the tolerance parameter (fraction of the optimal objective function value, gamma >= 1), Zopt is the optimal objective function value.

   This example uses a deterministic model formulation of the two-stage probabilisitc optimization formulation (fixed data inputs and outputs, [Wilchfort and Lund, 1997])
   that minimizes the expected costs (minimize mean value).

   Numbers and actions for Amman, Jordan water utility circa 2004. Data collected during
   interviews, meetings, and follow-up visits in Amman, Jordan with 21 professionals
   working at MWI, WAJ, JVA, LEMA, USAID, and in private consultation from
   November 2005 through January 2006. The underlying two-stage determinization mixed-integer optimization model and
   data for Amman, Jordan are described in: David E. Rosenberg and Jay Lund (2009). "Modeling Integrated Water Utility
   Decisions with Recourse and Uncertainty". Water Resources Management. 23 (1), pp. 85-115. doi: 10.1007/s11269-008-9266-4.
   http://www.springerlink.com/content/k7h71596u3065104/

   Can also resolves model for uncertain demand data for 2005, 2020, 2025, 2040 etc.
   Each year is indenpendent. Change the YtoUse parameter to control the demand forecast years.

   MODEL INPUTS:
        - From file AmmanJordanUtilOpt.gdx (model data and optimal solution generated by AmmanJordanUtilOptGen.gms to define Zopt in the near-optimal tolerance constraint).
        - LFIXED and LFIXEDVAL to specify fixed decision variable values for two decision variables (New Surface Water and Purchase Tanker Trucks)
           that are have large integer ranges but very small effectiveness. Fixing reduces the problem size. (Use
           AmmanJordanOptNearInt.gms to instead interactively specify the fixed decision variable values and inputs from the
           Parallel Coordinate plotting utility).

   MODEL OUTPUTS: file AmmanJordanOptNear.gdx
      Principal outputs are:
        - Cost data for each generated alternative (COSTS)
        - Long term decision variable results for each generated alternative (LONGACTS)
        - Information regarding the state of the looping that generated the alternatives (RUNDATA and LEVELDATA)

   The integer enumeration algorithm works as follows (see citations below for further descriptions):
   1) Find the maximum extents (lower and upper bounds within the near-optimal region) for each unfixed decision variable (Rosenberg (in review), Section 3, step b)
   2) Fix decision variables that have the same bounds at the common bounding value
   3) Identify all near-optimal integer alterantives by systematically crawling the near-optimal region using a grand
      WHILE loop. At each level (decision varaible), solve two optimization problems to identify the minimal and maximum extents of the variable
      given the orignal constraints, near optimal constraint, LFIXED limits, and prior decision variable values set at prior levels. Then iterate over
      the integer values for the current decision variable between the identified bounds and repeat at more interior levels. (Rosenberg (in review), Section 3.2).
      The levels and extents define a branching tree of the integer combinations that represent feasible near-optimal alternatives.
   4) Three extentions not reported in Rosenberg (in review) speed up the computation time of steps 1-3:
        a) Re-order the processing of decision variables from variables with smallest dynamic range to largest dynamic range (reduce number of branches in the tree
            and therefore decrease the number of optimization calls to find bounds for branches)
        b) At each level, re-order the enumartion of decision variable values to lowest, highest, lowest+1, highest-1, lowest+2, highest-2, .... For each enumerated decision
            variable value, solve for and track the extents for the next decision variable (level). Skip solving for the extents at the next level when the extents
            for the current enumerated value are the same as the extents for the prior enumerated value (e.g., extents for all intermediary values will also be the same;
            again reduce the number of optimization calls required to find bounds)
        c) On last decision variable, linearly interpolate objective function values on intermediary integer values using the objective function values identified by solves on the
             two bounding extents (again, avoid optimization solves for final intermediary integer values)

   RUN TIME: approximately 45 minutes. You can track run progress by opening the output file AmmanJordanOptNear.gdx
   and looking at the RUNDATA parameter. The gdx file will update every 500 bounding solves (parameter SolInterval).

   #####################
   Programmed by David E. Rosenberg

   Dept. of Civil & Env. Engineering and Utah Water Research Lab
   Utah State University
   david.rosenberg@usu.edu

   HISTORY
     - Programmed by David Rosenberg August 27, 2006 (U.C. Davis, Phd dissertation work)
     - Derives from UtilityTwoStateMYMV.gms
     - Near-optimal model formulation added by David Rosenberg February, 2012
     - Enumeration algorithm for Mixed-Integer Programs initially programmed March 2011 and recoded March 2014 as grand while loop
     - GDX data dump added February 2014, updated August 2014
     - Sped up mixed-Integer enumeration alogorithm per Step 4 above
     - Generate optimal solution and near-optimal integer alternatives for default settings on initial load of results in Matlab
        (Integer values for two actions with very small effectiveness set to values in optimal solution [New Surface Water = 0.1 MCM/year (level=5) and
         Purchase Tanker Trucks = 0.00 MCM/year (level=0) to reduce computational time by a factor of (5+1)*(25+1) = 156x).

   CITATION:
   Original description and Amman Example:
     David E. Rosenberg (2012). "Near-optimal water management to improve multi-objective decision making."
     2012 International Congress on Environmental Modelling and Software: Managing Resources of a Limited Planet:
     Pathways and Visions under Uncertainty, Sixth Biennial Meeting, Leipzig, Germany, pp. 104-111.
     http://www.iemss.org/sites/iemss2012//proceedings/A2_0656_Rosenberg.pdf

   LICENSING:
   This code is distributed AS-IS with no expressed or implied warranty regarding functionality. The entire code or parts
   may be used for non-commercial purposes so long as the use is cited per the citation above. Use for any commercial purpose requires
   prior written permission from the author. Use requires downloading and installing the General Algebraic Modeling System (www.gams.com)
   as well as licenses for the BDMLP and DICOPT solvers to solve mixed-integer and non-linear mixed integer programs.

   BUG REPORTS and FEEDBACK:
   This code is possibly laden with bugs so bug reports and feedback are much appreciated. Please submit via the the issue tracker on the
   GitHub repository where you downloaded this file.
   Note, that while much appreciated, there is no promise of when--or if--the bug will be fixed.

$Offtext
***************************************

OPTION limrow = 0
OPTION limcol = 0

***** Load the SETS at Execute time
$gdxin AmmanJordanUtilData
$LOAD
SETS  i Long term actions
      l(i) Long term conservation actions
      j Short term actions
      s Seasons
      e Hydrologic events
      m(j) conveyance actions for capacity expansion
      n(j) applied water for waste-water reuse
      sc scenario data
      y  demand year
      d  Data Uncertainty
      mvi Near optimal scenarios
      t time years
      cls Action classifications;
*      ModTyp Model Formulation Types
*                        /conm "constrain mean", conv "constrain variance", mobj "multi objective"/;
$LOAD i,l,j,s,e,m,n,sc,y,d,mvi,t,cls
$gdxin

Display i,l,j,s,e,m,n,sc,y,d,mvi,t;

Alias (e, e2);
Alias (s, s2);
Alias (i, i2);
Alias (j, j2);
*Alias (mvi, mvi2);

SCALARS
    tcap Current Treatment Plant Capacity (million m3 per year)
    disttype Distribution type (1=uniform  2=normal)
    r Discount rate
    SDWidth Width of data range (number of standard deviations)
    td Total demand (Mm3 per year)
    yd Year x demand (Mm3 per year)
    CThresh Cost threshold to end search (JD mill)
    CUST Number of customers
    mill One million /1000000/
    VLIMIT upper limit on variance
    MLIMIT upper limit on mean
    VHI   highest value of variance
    VLO   lowest value of variance
    MHI   highest value of mean
    MLO   lowest value of mean
    TRAD  tradeoff coefficient between mean and variance costs (fraction)
    GAMMA near optimal tolerance (fraction of optimal objective function value)
    FOPT  optimal value of objective function
    RunMode type of optimization problem to solve (1=optimum 2=bounds for unfixed variables 3=bounds for all variables 4=crawl all solutions) /4/
    InputPassed input passed to use as set values (1=levels [lFixedVal] 2=volumes [lFixedValVol]) /1/;

PARAMETERS
    cap(i,d) Capital Costs of long-term actions (JD Mill)
    life(i,d) Lifespan of long-term actions (years)
    Lmaxunits(i) Upper bound on long-term actions (units)
    ScWDem(i)    Upper limit scales with demand multiplier (0 or 1)
    Gadj(i,j) Interaction for long-term conservation action needs adjustment so short-term limit is greater than zero
    al(j)        Apparent loss (fraction of effectivess that is an apparent loss)
    ScWDemST(j)  Scales with demand for Short-term actions (fraction of demand)
    Lmaxp(i,d) Effectiveness of long-term actions (MCM per unit per year)
    C2(j,s,d) UCost of short-term actions (JD Mill per event)
    sf(i,s,d) Seasonal distribution of long-term action effectiveness (fraction)
    dem(e,s,d) Shortage in event e of season s (fraction of total demand)
    p(e,s,d) Probability of shortage in event e of season s (fraction)
    g(i,j,d) Interaction between long and short-term actions (fraction)
    Smaxp(j,s,d) Upper limit of short-term actions (MCM per event)
    rf(s,d)  return flow (fraction of applied water use)
    tl(s,d)  treatment loss (fraction of return flow)
    sd(s,d)  Seasonal distribution of demand (fraction of normal demand)
    demyr(y,e,d) Shortage in year y (fraction of total demand)
    pyr(y,e,d)     Probability of shortage event e in year y (fraction)
    basedem(y,d) Base demand in year y (MCM per year)
    OpCost(i,d) Operating cost for long-term actions that do not have short-term dummy (JD per m3)
    CstScWDem(i) Cost scales with demand (1 or 0)
    YtoUse(y)    Run model for demand year (1 = yes and 0 = no)
*    ModToUse(ModTyp)  Run tradeoff curve solution method (1 = yes and 0 = no)
    LFixed(i)    Long-term action is fixed (1 = fixed and 0=free)
    LTOUSE(i)    Long-term action to use in current near-optimal iteration (1=yes 0=no)
    LFixedVal(i)   Value to fix long-term action at (integer levels)
    LFixedValVol(i) Volume to fix long-term action at (MCM per year)
    LngCls(i,cls) Classification of long-term actions;


** To deal with variable number of data scenarios for robust model
Set bs Bases /b1 * b3/;

PARAMETER
   BaseVals(bs) /b1 1, b2 2, b3 5/
   ScenToUse(sc) Indicator of which scenarios to use;

SCALAR BaseIn Base index to start at
       BasePo Base power to start at;


** To deal with annualized discounting for long-term capital costs
PARAMETER AMORT(t) Amortization of capital cost;

Set CostTyp Types of cost /Long, Short, Total, Variance, MLimit, VLimit, SolStat, ModStat, NumScen, ItsUsd, NumEqu, NumVar, SolTime/
    Const   Constraint Type /Deliv2, Convey5, WWT6, prob, volum, variance/
    ModDat  Data for model /cost, level, volum, marg, maxvolum/
    Dum    Has one element /Val/;

********** Deterministic Model Formulation **********************
*     Deterministic versions of parameters, use average of Min and Max
      PARAMETERS
      cap_DET(i)       Capital cost of long-term actions (JD million)
      life_DET(i)      Lifespan of long-term actions (years)
      AMRTFC_DET(i)    Amortized fraction for long-term action (fraction)
      c1_DET(i)        Annualized capital cost for long-term actions (JD million per year)
      c2_DET(j,e,s)    Unit cost for short-term action (JD per m3 per event)
      p_DET(e,s)       Probability of shortage event e in season s (fraction)
      dem_DET(e,s)     Shortage in event e of season s (fraction of td)
      sf_DET(i,s)      Seasonal distribution of long-term action effectiveness (fraction)
      lmaxp_DET(i)     Effectivenes of long-term action (Mm3 per unit per year)
      smaxp_DET(j,e,s) Upper limit of short-term action (Mm3 per event)
      g_DET(i,j,s,e)       Supply enhancement interaction factor (1 or 0)
      rf_DET(s)        Return flow factor (fraction of applied water)
      tl_DET(s)        Treatment loss factor (fraction of return flow)
      sd_DET(s)        Seasonal distribution of demand (fraction of normal demand)
      ScDem_DET(e,s)   Demand scale factor (fraction above normal demand);

      Parameter SDef(s,e) Seasonal deficit
                SUse(s,e) Sesason to use;
      SCALAR    MinVal    Minimum value;


*     Error checking on upper limits for constraint 4
      Parameter E4_DET(j,e,s) Upper limit for deterministic equation 2
                E4_DS(j,e,s,sc) Upper limit for scenario equation 2;

*     Error checking on upper limits for constraint 2
      Parameter E2_DET(e,s) Upper limit for deterministic equation 2;

      VARIABLES
      DET_S(J,S,E)  Short term action for season S event E (million m3 per seas.)
      DET_L(I)      Long term action (units)
      DET_SLACK(S,E) Slack variable on meet shortage constraint (million m3 per seas.)
      DET_TCOST     Total expected annual cost for actions (JD Millions)
      DET_VCOST     Variance in annual cost for actions (JD millions)
      DET_MOCOST    Multi-objective combo of mean and variance costs (crazy units)
      L_VAL          Long term action value to use in current iteration of near optimal algorithm;

      POSITIVE VARIABLE   DET_S;
      INTEGER VARIABLE    DET_L;
*     Susinct way of representing non-negativity constraints [eq 7]

      EQUATIONS
      DEQ1        Objective function cost (JD Mill) [equation 1]
      DEQ2(S,E)   Action effectiveness must meet or exceed seasonal and event shortages (Mm3) [eq 2]
      DEQ3(I)     Long term actions less than limits (integer) [eq 3]
      DEQ4(J,S,E) Upper limits for short-term actions with supply enhancement or demand hardening interactions (Mm3 per season)[eq 4]
      DEQ5(S,E)   Distribution system capacity (Mm3 per season) [eq 5]
      DEQ6(S,E)   Mass balance on treated wastewater treated wastewater (Mm3 per season)[eq 6]
      DEQ7        Calculation of variance in cost (JD Mill) [eq 7]
      DEQ8        Constraint on variance in cost [eq 8]
      DEQ9        Constraint on mean cost [eq 9]
      DEQ10       Calculation of tradeoff in mean-variance costs [eq 10]
      DEQ11(S,E)  Action effectiveness plus slack variable must equal seasonal and event shortages (Mm3) [eq 11]
      DEQ12(S,E)  Either Slack variable or short term actions must be zero [eq 12]
      DEQ13       Near optimal tolerance (objective function units) [Eq 13]
      DEQ14       Long-term action value for current near optimal tolerance iteration (units of the long term action) [Eq 14];


      DEQ1..        SUM(I, c1_DET(I)*DET_L(I)) +  SUM((S,E,J), p_DET(E,S)*c2_DET(J,E,S)*DET_S(J,S,E)) =E= DET_TCOST;
      DEQ2(S,E)..   SUM(l, sf_DET(l,S)*(1+ScWDem(l)*ScDem_DET(e,s))*Lmaxp_DET(l)*DET_L(l)) + SUM(J, (1-al(j))*DET_S(J,S,E)) =G=
                      sd_DET(S)*td*dem_DET(E,S);
      DEQ3(I)..      DET_L(I) =L= Lmaxunits(I);
      DEQ4(J,S,E).. DET_S(J,S,E) =L= Smaxp_DET(J,E,S)*(1+ScWDemST(j)*ScDem_DET(e,s)) + SUM(I, sf_DET(i,s)*g_DET(i,j,s,e)*(1+ScWDem(i)*ScDem_DET(e,s))*Lmaxp_DET(i)*DET_L(i));
      DEQ5(S,E)..   SUM(m, DET_S(m,S,E)) =L= sf_DET("ExpandCap",S)*(TCAP + Lmaxp_DET("ExpandCap")*DET_L("ExpandCap"));
      DEQ6(S,E)..   DET_S("ReuseWW",S,E) =L= rf_DET(s)*tl_DET(s)*SUM(n, DET_S(n,S,E));

      DEQ7..        SUM((S,E), p_DET(E,S)*sum(J, abs(c2_DET(J,E,S)*DET_S(J,S,E)  -  SUM((S2,E2,J2), p_DET(E2,S2)*c2_DET(J2,E2,S2)*DET_S(J2,S2,E2)))**2)) =E=DET_VCOST;
      DEQ8..        SUM((S,E), p_DET(E,S)*sum(J, abs(c2_DET(J,E,S)*DET_S(J,S,E)  -  SUM((S2,E2,J2), p_DET(E2,S2)*c2_DET(J2,E2,S2)*DET_S(J2,S2,E2)))**2)) =L= VLIMIT;
      DEQ9..        SUM(I, c1_DET(I)*DET_L(I)) +  SUM((S,E,J), p_DET(E,S)*c2_DET(J,E,S)*DET_S(J,S,E)) =L= MLIMIT;
      DEQ10..       (1 - TRAD)*(SUM(I, c1_DET(I)*DET_L(I)) +  SUM((S,E,J), p_DET(E,S)*c2_DET(J,E,S)*DET_S(J,S,E))) +
                         (TRAD)*SUM((S,E), p_DET(E,S)*sum(J, abs(c2_DET(J,E,S)*DET_S(J,S,E)  -  SUM((S2,E2,J2), p_DET(E2,S2)*c2_DET(J2,E2,S2)*DET_S(J2,S2,E2)))**2))
                                  =E= DET_MOCOST;
      DEQ11(S,E)..   SUM(l, sf_DET(l,S)*(1+ScWDem(l)*ScDem_DET(e,s))*Lmaxp_DET(l)*DET_L(l)) + SUM(J, (1-al(j))*DET_S(J,S,E)) + DET_SLACK(S,E) =E=
                      sd_DET(S)*td*dem_DET(E,S);
      DEQ12(S,E)..  SUM(J, (1-al(j))*DET_S(J,S,E))* DET_SLACK(S,E) =E= 0;
      DEQ13..       DET_TCOST =L= GAMMA*FOPT;
      DEQ14..       SUM(i, LTOUSE(i)*DET_L(i)) =E= L_VAL;

* unconstrained model
      MODEL TWOSTAGE_DETUN /DEQ1, DEQ2, DEQ3, DEQ4, DEQ5, DEQ6, DEQ7, DEQ11, DEQ12/;
* near-optimal
      MODEL TWOSTAGE_DETNE /DEQ1, DEQ2, DEQ3, DEQ4, DEQ5, DEQ6, DEQ7, DEQ11, DEQ12, DEQ13, DEQ14/;

* min mean, constrain variance model
      MODEL TWOSTAGE_DETCO /DEQ1, DEQ2, DEQ3, DEQ4, DEQ5, DEQ6, DEQ7, DEQ8, DEQ11, DEQ12/;
* min variance, constrain mean model
      MODEL TWOSTAGE_DETMCO /DEQ1, DEQ2, DEQ3, DEQ4, DEQ5, DEQ6, DEQ7, DEQ9, DEQ11, DEQ12/;
* Multi-objective tradeoff model
      MODEL TWOSTAGE_DETMOBJ /DEQ1, DEQ2, DEQ3, DEQ4, DEQ5, DEQ6, DEQ7, DEQ10, DEQ11, DEQ12/;


*Solve Options
OPTION MIP = BDMLP;
OPTION MINLP = DICOPT;
*OPTION MINLP = BARON;
TWOSTAGE_DETUN.ITERLIM = 25000;
TWOSTAGE_DETNE.ITERLIM = 25000;
TWOSTAGE_DETCO.ITERLIM = 25000;
TWOSTAGE_DETMCO.ITERLIM = 25000;
TWOSTAGE_DETMOBJ.ITERLIM = 25000;

*TWOSTAGE_DS.ITERLIM = 50000;

******** DEFINITIONS OF SETS & PARAMETERS TO FORMAT OUTPUT ***********************
SET sol Solutions generated /sol1*sol100000/
    levs Level data /Rank, Level, LBnd, UBnd, CurrV, SolStat, ModStat, SolGen/;


*    use Dum as last parameter dimension to force into row normalized form
*    when output to Excel for use by pivot tables


PARAMETERS
    LongActs(y,sol,mvi,i,ModDat,Dum) Values for long-term actions
    MargLT(y,sol,mvi,i,Dum)  Reduced costs (marginals) for long-term actions
    Lives(i)   Lifespan of long-term actions
    ConstShad(y,Const,S,E,mvi,d,Dum) Shadow values on constraints
    ShortActs(y,j,s,e,mvi,d,dum) Data values for short-term actions in each data scenario
    BaseDemOut(y,d)      Base demand to output to excel
    Costs(y,sol,mvi,CostTyp,Dum) Cost parts for models
    SCCosts(y,d,mvi,CostTyp,dum) Value of cost component
    VLimValues(y,d,mvi) Upper limit on variance
    MLimValues(y,d,mvi) Upper limit on mean
    TradVals(y,mvi)     Tradeoff coefficient value
    LongActsOpt(y,i,ModDat,Dum) Optimal Values for long-term actions
    CostsOpt(y,CostTyp,Dum) Cost parts for Optimal solution
    LevelData(y,sol,mvi,Levs,Dum) Level data for iterations
    YtoUse(y) Data on enumeration levels
    STBound(j,s,e) Short term bound to use when a corresponding long-term action is fixed (MCM)
;

* LOAD in the all the prior results from the GDX file
Execute_load 'AmmanJordanUtilOpt.gdx',
    tcap
    disttype
    r
    SDWidth
    td
    yd
    CThresh
    CUST
    mill
    VLIMIT
    MLIMIT
    VHI
    VLO
    MHI
    MLO
    TRAD
    GAMMA
    FOPT
    cap
    life
    Lmaxunits
    ScWDem
    Gadj
    al
    ScWDemST
    Lmaxp
    C2
    sf
    dem
    p
    g
    Smaxp
    rf
    tl
    sd
    demyr
    pyr
    basedem
    OpCost
    CstScWDem
    YtoUse
    AMORT
    LngCls
    cap_DET
      life_DET
      AMRTFC_DET
      c1_DET
      c2_DET
      p_DET
      dem_DET
      sf_DET
      lmaxp_DET
      smaxp_DET
      g_DET
      rf_DET
      tl_DET
      sd_DET
      ScDem_DET
      SDef
      SUse
      MinVal
      E4_DET
      E4_DS;

*Step to dummy from start
LFixedValVol(i) = 0;
LFIXED(i) = 0;
LFixedVal(i) = 0;
LToUse(i) = 0;
LToUse(i)$(ord(i) eq 2) = 1;

DISPLAY LToUse;

*Disable read from MATLAB
$ontext
**** Read in data for LFixed, LFixedVal, LFixedValVol, InputPassed, GAMMA passed by MATLAB
execute_load 'matdata2.gdx', LFIXED, LFixedVal, InputPassed, LFixedValVol, GAMMA, RunMode;
$offtext
* Instead set and read fixed values for New surface water and purchase tanker trucks from optimal values because the range of
* integer options for these decision variables are large and costs + effectivenes are extremely small. These set values will reduce the problem to a manageable size.

SET iToFix(i) Long term actions to fix to optimal value /NewSW, PurTankT/;
PARAMETER LongActsOpt(y,i,ModDat,Dum) Optimal Values for long-term actions;

Execute_load 'AmmanJordanUtilOpt.gdx',LongActsOpt;
LFIXED(iToFix) = 1;

DISPLAY LToUse, LFixed, LFixedVal, LFixedValVol;

**** PARAMETERS TO HANDLE Looping CRAWL
PARAMETERS
  LToLoop(i) Decision variables to loop over (1=yes 0=no)
  Bounds(d,i) Bounds on decision variable (integer levels)
  CurrBounds(d,i) Most recently calculated bounds on decision variables (integer levels)
  LastBounds(d)  Bounds on the last decision variable (integer levels)
  WorkBounds(d,i) Current working bounds at level i used to narrow search range (integer levels)
  PrevBounds(d,i) Bounds at level i from prior iteration at level i-1 (integer levels)
  ObjVals(d)     Objective function value at bounding values for the last deicsion variable ($)
  XCURR(i)    Current decision variable value (integer levels)
  XCOUNT(i)   Number of integer values considered at level i (count)
  XRange(i)   Number of integer values at level i between the identified bounds (integer levels)
  SkipFindBounds(i) Flag takes a value of one to indicate do not search use prior bounds for level i (1=skip 0=find)
  vFixedCurr(i) Current decision variable is fixed (1=yes 0=no)
  vTurnedFixed(i) Decision variables that were turned to fixed because of equal extents (1=yes 0=no)
  IndCount(i) Count of indexes
  Adjust(d)  Adjustment to bound /min 1, max -1/
  Range(i) Range on bounds for decision variable
  RankRange(i)  Rank of the range for decision variable i (1=smallest range n=largest range)
  RankLevel(i) Level of the decision variable with range rank i (1=first n=last)
  LevelStillToUse(i) Index of levels still available for ranking (1=yes 0=no);

IndCount(i) = ord(i);

SCALARS
  level Current decision variable /1/
  FirstX First unfixed decision variable /1/
  LastX  Last unfixed decision variable /1/
  NumSolvs Number of optimization solves made /0/
  NumSols Number of solutions logged /0/
  CurrLB Current lower bound
  CurrUB Current upper bound
  CurrV  Current value
  xLAST  last decision variable level
  InnerLevel inner decision variable level
  cMin Current minimum range
  Rank current rank
  RankFirstUnfixed Rank of the first unfixed variables (number of fixed variables + 1)
  MaxPosAlt Maximum possible alternatives by brute force combination
  CurrPosAlt Current possible alternatives considered if by brute force
  FractAlts  Fraction of maximum possible alternatives considered
  SearchEfficiency Number of solves divided by CurrPosAlt by brute force;

*** Sets and Parameters to keep track of how the CRAWL enumeration loop is progressing
SETS sInds Alternative indexes /s1*s1000/
     tData Data field about the runs /NumSols, NumSolvs, ElapsedTime, CurrPosAlts, FractAlts/;
SCALAR SolInterval Interval over which to log enumeration progress (# of alternatives generated) /500/
       SolIntInd   Index of alternatives logged (#) /0/;
PARAMETER RunData(sInds,tData) Data about the progress of enumeration;

RunData(sInds,tData) = 0;

FirstX = card(i);
LastX = card(i);

FirstX = smin(i$(LFixed(i) eq 0),IndCount(i));
LastX = smax(i$(LFixed(i) eq 0),IndCount(i));

*Loop over demand years
Loop (y$YtoUse(y),
*** Prepare input values

    p(e,s,d) = pyr(y,e,d);
    dem(e,s,d) = demyr(y,e,d);
    yd = (basedem(y,"min") + basedem(y,"max"))/2;

*   Deterministic input values
    dem_DET(e,s) = (dem(e,s,"max")+dem(e,s,"min"))/2;
    p_DET(e,s) = (p(e,s,"max")+p(e,s,"min"))/2;
    g_DET(i,j,s,e) = (g(i,j,"max")+g(i,j,"min"))/2;
    ScDem_DET(e,s) = yd / td - 1;
    ScDem_Det(e,s)$(yd le 0) = 0;
*   Adjust probability of last event or season so fractions sum to 1
    p_DET(e,s)$(ord(e) eq card(e)) = 1 - SUM(e2$(ord(e2) ne card(e2)),p_DET(e2,s));
*   Adjust interaction values of g to avoid infeasibilities (negatives right-hand sides for equation 4)
    Loop((i,j)$Gadj(i,j),
         SDef(s,e) = (Smaxp_DET(j,"e1",s)*(1+ScWDemST(j)*ScDem_DET(e,s)) + sum(i2$(g_DET(i2,j,s,e) lt 0),g_DET(i2,j,s,e)*(1+ScWDem(i2)*ScDem_DET(e,s))*Lmaxp_DET(i2)*sf_DET(i2,s)))/(Lmaxp_DET(i)*sf_DET(i,s)*(1+ScWDem(i)*ScDem_DET(e,s)));
         SUse(s,e) = 0;
         MinVal = 0;
         Display SDef;
*        Find minimum Sdef
         Loop ((s,e),
             If (SDef(s,e) lt MinVal,
                 MinVal = SDef(s,e);
                 );
             );
         If (MinVal lt 0,
            g_DET(i,j,s,e) = g_DET(i,j,s,e) - MinVal;
            );
         );

    Display g_det;

    if (InputPassed eq 2,
*        Matlab is passing the input LFixedValVol which are in units of water volume and we need to convert to levels and round to an integer.
         LFixedVal(i) = floor(LFixedValVol(i)/((1+ScWDem(i)*Sum((e,s),ScDem_DET(e,s))/(card(e)*card(s)))*Lmaxp_DET(i)) + 0.5);
         );

*   Set limits on short term variables

    DET_SLACK.LO(S,E) = -(SUM(l, sf_DET(l,S)*(1+ScWDem(l)*ScDem_DET(e,s))*Lmaxp_DET(l)*Lmaxunits(l)) -  sd_DET(S)*td*dem_DET(E,S));
    DET_SLACK.LO(S,E)$(DET_SLACK.LO(S,E) gt 0) = 0;
    DET_SLACK.UP(S,E) = 0;

*   Set fixed values for select variables that have very low costs and small effectivenesses
    LFIXEDVAL(iToFix) = LongActsOpt(y,iToFix,"level","Val");

    LFixedVal(i)$(LFIXED(i) eq 0) = 0;

    DISPLAY InputPassed, LFixedVal, LFixedValVol;

*** Loop over mvi near optimal scenarios
    Loop (mvi,

    NumSols = 1;
    NumSolvs = 1;
    Bounds(d,i) = 0;
    XCurr(i) = 0;
    vTurnedFixed(i) = 0;
    vFixedCurr(i) = LFixed(i);

    If (sum(i,LFIXED(i)) eq card(i),
*        All the decision variables are fixed. Just need one solve and really we're just testing to see whether the solution is feasible
         FirstX = 1;
         LToUse(i) = 0;
         LastX = 1;
    else


*** Solve for the optimal solution
*      Set up limits on long-term variables
       DET_L.UP(i) = Lmaxunits(I);
       DET_L.LO(i) = 0;

*      Fixed variables are constrained to their values
       DET_L.FX(i)$(LFIXED(i)) = LFixedVal(i);

*      Constrain short-term varaibles
*      start with upper bound of total demand
       STBound(j,s,e) =  sd_DET(S)*td*dem_DET(E,S);
*      Adjust down if the actual bound is lower
       STBound(j,s,e)$(Smaxp_DET(J,E,S)*(1+ScWDemST(j)*ScDem_DET(e,s)) + SUM(I, sf_DET(i,s)*g_DET(i,j,s,e)*(1+ScWDem(i)*ScDem_DET(e,s))*Lmaxp_DET(i)*LFixedVal(i)) lt STBound(j,s,e)) =
                  Smaxp_DET(J,E,S)*(1+ScWDemST(j)*ScDem_DET(e,s)) + SUM(I, sf_DET(i,s)*g_DET(i,j,s,e)*(1+ScWDem(i)*ScDem_DET(e,s))*Lmaxp_DET(i)*LFixedVal(i));

*       DET_S.LO(J,S,E)$SUM(I, g_DET(i,j,s,e)*LFIXED(i)) = STBound(j,s,e);
       DET_S.LO(J,S,E) = 0;
       DET_S.L(J,S,E)$SUM(I, g_DET(i,j,s,e)*LFIXED(i)) = STBound(j,s,e);

       Display STBound,DET_S.LO;


*       DISPLAY DET_L.UP,DET_L.LO;

*      Initialize solution start point
       DET_L.L(I) = DET_L.UP(I);
       DET_SLACK.L(S,E) = 0;

       SOLVE TWOSTAGE_DETNE USING MINLP MINIMIZING DET_TCOST;

*           Log the solution
            loop(sol$(ord(sol) eq NumSols),
                LongActs(y,sol,mvi,i,"level","Val") = DET_L.L(i);
                LongActs(y,sol,mvi,i,"cost","Val") = DET_L.L(i)*c1_DET(i);
                LongActs(y,sol,mvi,i,"marg","Val") = DET_L.M(i);
                LongActs(y,sol,mvi,i,"volum","Val") = (1+ScWDem(i)*Sum((e,s),ScDem_DET(e,s))/(card(e)*card(s)))*Lmaxp_DET(i)*DET_L.L(i);
                Costs(y,sol,mvi,"Total","Val") = DET_TCOST.L;
                Costs(y,sol,mvi,"Long","Val") = SUM(I, C1_DET(I)*DET_L.L(I));
                Costs(y,sol,mvi,"Variance","Val") = DET_VCOST.L;
                Costs(y,sol,mvi,"SolStat","Val")= TWOSTAGE_DETNE.SOLVESTAT;
                Costs(y,sol,mvi,"ModStat","Val") = TWOSTAGE_DETNE.MODELSTAT;
                Costs(y,sol,mvi,"ItsUsd","Val") = TWOSTAGE_DETNE.ITERUSD;
                Costs(y,sol,mvi,"NumEqu","Val") = TWOSTAGE_DETNE.NUMEQU;
                Costs(y,sol,mvi,"NumVar","Val") = TWOSTAGE_DETNE.NUMVAR;
                Costs(y,sol,mvi,"SolTime","Val") = TWOSTAGE_DETNE.RESUSD;

                LevelData(y,sol,mvi,"Rank","val") = 0;
                LevelData(y,sol,mvi,"Level","val") = 0;
                LevelData(y,sol,mvi,"LBnd","val") = 0;
                LevelData(y,sol,mvi,"UBnd","val") = 0;
                LevelData(y,sol,mvi,"CurrV","val") = 0;
                LevelData(y,sol,mvi,"ModStat","val") = TWOSTAGE_DETNE.MODELSTAT;
                LevelData(y,sol,mvi,"SolStat","val") = TWOSTAGE_DETNE.SOLVESTAT;
                LevelData(y,sol,mvi,"SolGen","val") = 1;

                );


*        At least one decision variable is not fixed. If RunMode >= 2, we first need to
*        Identify the lower and upper bounds (maximum extents) for the appropriate decision variables

    if (RunMode eq 3,
*        Do them all
         LToLoop(i) = 1;
    else
*        Only do unfixed variables
         LToLoop(i) = (LFIXED(i) eq 0);
         );


    Loop (i2$(LToLoop(i2) and (RunMode ge 2)),
       LToUse(i) = 0;
       LToUse(i2) = 1;

*** Find lower and upper bound for the selected decision variable ower bounds
    Loop (d,

*      Set up limits on long-term variables
       DET_L.UP(i) = Lmaxunits(I);
       DET_L.LO(i) = 0;

*      Fixed variables are constrained to their values
       if (RunMode eq 3,
*         except the current decision variable
          DET_L.FX(i)$(LFIXED(i) and (ord(i) ne ord(i2))) = LFixedVal(i);
       else
          DET_L.FX(i)$(LFIXED(i)) = LFixedVal(i);
          );

*      Initialize solution start point
       DET_L.L(I) = DET_L.UP(I);
       DET_SLACK.L(S,E) = 0;

*      Constain short-term varaibles
*      start with upper bound of total demand
       STBound(j,s,e) =  sd_DET(S)*td*dem_DET(E,S);
*      Adjust down if the actual bound is lower
       STBound(j,s,e)$(Smaxp_DET(J,E,S)*(1+ScWDemST(j)*ScDem_DET(e,s)) + SUM(I, sf_DET(i,s)*g_DET(i,j,s,e)*(1+ScWDem(i)*ScDem_DET(e,s))*Lmaxp_DET(i)*DET_L.L(i)) lt STBound(j,s,e)) =
                  Smaxp_DET(J,E,S)*(1+ScWDemST(j)*ScDem_DET(e,s)) + SUM(I, sf_DET(i,s)*g_DET(i,j,s,e)*(1+ScWDem(i)*ScDem_DET(e,s))*Lmaxp_DET(i)*DET_L.L(i));

*       DET_S.LO(J,S,E)$SUM(I, g_DET(i,j,s,e)*LFIXED(i)) = STBound(j,s,e);
       DET_S.LO(J,S,E) = 0;
       DET_S.L(J,S,E)$SUM(I, g_DET(i,j,s,e)*LFIXED(i)) = STBound(j,s,e);

       If (ord(d) eq 1,
*        Minimizing, solve for lower bound
         SOLVE TWOSTAGE_DETNE USING MINLP MINIMIZING L_VAL;
         );

       If (ord(d) eq 2,
*        Maximizing, solve for the upper bound
         SOLVE TWOSTAGE_DETNE USING MINLP MAXIMIZING L_VAL;
         );

       Bounds(d,i2) = DET_L.L(i2);

       NumSols = NumSols+1;

*           Log the solution
            loop(sol$(ord(sol) eq NumSols),
                LongActs(y,sol,mvi,i,"level","Val") = DET_L.L(i);
                LongActs(y,sol,mvi,i,"cost","Val") = DET_L.L(i)*c1_DET(i);
                LongActs(y,sol,mvi,i,"marg","Val") = DET_L.M(i);
                LongActs(y,sol,mvi,i,"volum","Val") = (1+ScWDem(i)*Sum((e,s),ScDem_DET(e,s))/(card(e)*card(s)))*Lmaxp_DET(i)*DET_L.L(i);
                Costs(y,sol,mvi,"Total","Val") = DET_TCOST.L;
                Costs(y,sol,mvi,"Long","Val") = SUM(I, C1_DET(I)*DET_L.L(I));
                Costs(y,sol,mvi,"Variance","Val") = DET_VCOST.L;
                Costs(y,sol,mvi,"SolStat","Val")= TWOSTAGE_DETNE.SOLVESTAT;
                Costs(y,sol,mvi,"ModStat","Val") = TWOSTAGE_DETNE.MODELSTAT;
                Costs(y,sol,mvi,"ItsUsd","Val") = TWOSTAGE_DETNE.ITERUSD;
                Costs(y,sol,mvi,"NumEqu","Val") = TWOSTAGE_DETNE.NUMEQU;
                Costs(y,sol,mvi,"NumVar","Val") = TWOSTAGE_DETNE.NUMVAR;
                Costs(y,sol,mvi,"SolTime","Val") = TWOSTAGE_DETNE.RESUSD;

                LevelData(y,sol,mvi,"Rank","val") = 0;
                LevelData(y,sol,mvi,"Level","val") = ord(i2);
                LevelData(y,sol,mvi,"LBnd","val") = 0;
                LevelData(y,sol,mvi,"UBnd","val") = 0;
                LevelData(y,sol,mvi,"CurrV","val") = 0;
                LevelData(y,sol,mvi,"ModStat","val") = TWOSTAGE_DETNE.MODELSTAT;
                LevelData(y,sol,mvi,"SolStat","val") = TWOSTAGE_DETNE.SOLVESTAT;
                LevelData(y,sol,mvi,"SolGen","val") = 2;

                if (RunMode eq 3,
                   LevelData(y,sol,mvi,"SolGen","val") = 3;
                   );
                );

       );
*      end of d loop
    NumSolvs = NumSolvs+2;
    );
* end of i2 (unfixed decision variable) loops

*** SECOND STEP OF CRAWL
*   if any of the lower and upper bounds for unfixed variabiles are identical
*   we will fix those variables to save lots of time later
   vTurnedFixed(i)$((LFIXED(I) eq 0) and (Bounds("min",i) eq Bounds("max",i))) = 1;
   LFIXED(i)$vTurnedFixed(i) = 1;
   LFixedVal(i)$vTurnedFixed(i) = Bounds("min",i);
   vFixedCurr(i) = LFixed(i);

   FirstX = smin(i$(vFixedCurr(i) eq 0),IndCount(i));
   LastX = smax(i$(vFixedCurr(i) eq 0),IndCount(i));
   );
* end of the if all variables were fixed

*** SET UP THE INDEXES for the looping
BOUNDS(d,i)$LFIXED(i) = LFixedVal(i);
XCurr(i)$(ord(i) eq FirstX) = Bounds("min",i);
XCurr(i)$LFixed(i) = LFixedVal(i);
MaxPosAlt = prod(i$(LFixed(i) eq 0),(1+Bounds("max",i)-Bounds("min",i)));

if (RunMode ge 4,
   LEVEL = FirstX;

   if (MaxPosAlt gt 10,
*      Turn off solution listing since we may have a lot of solves
       TWOSTAGE_DETNE.solPrint = 2;
       );

*  Sort the decision variables by their dynamic ranges (difference in bounds) from smallest
*  to largest to promote more efficient crawling (STEP 4a)
   Rank = 1;
   Range(i) = Bounds("max",i)-Bounds("min",i);
   RankRange(i) = 0;
   RankLevel(i) = 0;
   LevelStillToUse(i) = 1;
   Loop(i,
      cMin = smin(i2$LevelStillToUse(i2),Range(i2));
      Rank = smin(i2$(LevelStillToUse(i2) and (Range(i2) eq cMin)),ord(i2));
      RankRange(i2)$(ord(i2) eq Rank) = ord(i);
      RankLevel(i) = Rank;
      LevelStillToUse(i2)$(ord(i2) eq Rank) = 0;
      );

*  Initialize counters according to sorted differences in bounds
   Rank = sum(i,vFixedCurr(i))+1;
   RankFirstUnfixed = Rank;
   Level = sum(i$(ord(i) eq Rank),RankLevel(i));
   FirstX = Level;
   LastX = smax(i$(ord(i) eq card(i)),RankLevel(i));

   Display LFixed, vFixedCurr, vTurnedFixed, MaxPosAlt;
   Display Bounds, XCurr, Range, RankRange,RankLevel;
   Display Rank, Level, FirstX, LastX;

   );

CurrBounds(d,i) = Bounds(d,i);
WorkBounds(d,i) = Bounds(d,i);
SkipFindBounds(i) = 0;
xCount(i) = 1;
xRange(i) = CurrBounds("max",i) - CurrBounds("min",i)+1;
XCurr(i)$(ord(i) eq FirstX) = CurrBounds("min",i);

$ontext
BEGIN THE LOOPING to CRAWL.
Level = the index of the current decision variable
RankLevel = the levels sorted by smallest->largest dynamic range of variable values to specify the
            order in which to move through variables in the enumeration.
            More efficient searching (fewer calls to find bounds) if start with variables with smaller
            dynamic ranges [fewer branches) in the root part of the tree, then move to larger ranges (more branches)
            at the tree extremities (Again, see Step 4a).
$offtext

while (sum(i$(ord(i) eq FirstX),xCount(i) le xRange(i)) and (RunMode ge 4),

*   Calculate current state
    CurrLB = sum(i$(ord(i) eq Level),CurrBounds("min",i));
    CurrUB = sum(i$(ord(i) eq Level),CurrBounds("max",i));
    CurrV = sum(i$(ord(i) eq Level),xCurr(i));

    if (NumSolvs le 200,
         display Rank, LEVEL, CurrV, CurrLB, CurrUB,NumSolvs, NumSols;
         display SkipFindBounds, vFixedCurr;
         );

    if (NumSolvs ge SolInterval*(1+SolIntInd),
*        Log current results
         SolIntInd = SolIntInd+1;

         LongActs(y,sol,mvi,i,ModDat,Dum)$((ord(sol) le NumSols) and YtoUse(y)) = LongActs(y,sol,mvi,i,ModDat,Dum) + EPS;
         Costs(y,sol,mvi,CostTyp,Dum)$((ord(sol) le NumSols) and YtoUse(y)) =   Costs(y,sol,mvi,CostTyp,Dum) + EPS;
         LevelData(y,sol,mvi,Levs,Dum)$((ord(sol) le NumSols) and YtoUse(y)) =   LevelData(y,sol,mvi,Levs,Dum) + EPS;
         CurrPosAlt = sum(i$(ord(i) ge RankFirstUnfixed),sum(i2$(ord(i) eq RankRange(i2)),(xCurr(i2) - Bounds("min",i2)))*
                 prod(i2$(RankRange(i2) gt ord(i)),(Bounds("max",i2)-Bounds("min",i2)+1)) )+1;
         FractAlts = CurrPosAlt/MaxPosAlt;
         SearchEfficiency = NumSolvs/CurrPosAlt;
*        Move the results to compact data representation over time
         loop(sInds$(ord(sInds) eq SolIntInd),
            RunData(sInds,"NumSols") = NumSols;
            RunData(sInds,"NumSolvs") = NumSolvs;
            RunData(sInds,"ElapsedTime") = timeElapsed;
            RunData(sInds,"CurrPosAlts") = CurrPosAlt;
            RunData(sInds,"FractAlts") = FractAlts;
            );

         Execute_Unload 'AmmanJordanOptNear.gdx';
         );


    if (LEVEL eq LastX,
*           Last level. Calculate objective function values for alternatives with
*              decision variable values for the last variable within it's
*              previously determined ranages.
*           All other levels have specified values. Action depends on the range of
*              allowable decision variable values for this last variable.
*           If the lower and upper bounds are the same, simply calculate the
*              objective function value for this single alternative.
*           If the lower and upper bounds are the only decision variable values
*              in the range, calculate objective function values for each bound
*              and we are done.
*           If there are additional decision variable values between the bounds,
*              interpolate objective function values from the bounds

*           Set up to calculate the objective function value
*           Dummy setting for vLToUse; don't need in single solve mode
            LToUse(i) = 0;
            LToUse(i)$(ord(i) eq level) = 1;
            vFixedCurr(i)$(ord(i) eq level) = 1;

*           Set up limits on long-term variables
            DET_L.UP(i) = Lmaxunits(I);
            DET_L.LO(i) = 0;

*           Fixed variables are constrained to their values
            DET_L.FX(i)$(vFixedCurr(i)) = XCurr(i);

            LastBounds(d) = sum(i$(ord(i) eq LEVEL),CurrBounds(d,i));

            Loop(d$((ord(d) eq 1) or (LastBounds("max") gt LastBounds("min"))),
*               Set fixed value for this decision variable to the current bound
                DET_L.FX(i)$(ord(i) eq LEVEL) = CurrBounds(d,i);
*      *        Initialize solution start point
                DET_L.L(I) = DET_L.UP(I);
                DET_SLACK.L(S,E) = 0;

*      *        Everything is fixed, find the minimum cost
                SOLVE TWOSTAGE_DETNE USING MINLP MINIMIZING DET_TCOST;

*      *        Log the solution
                NumSolvs = NumSolvs+1;
                NumSols = NumSols+1;
                loop(sol$(ord(sol) eq NumSols),
                    LongActs(y,sol,mvi,i,"level","Val") = DET_L.L(i);
                    LongActs(y,sol,mvi,i,"cost","Val") = DET_L.L(i)*c1_DET(i);
                    LongActs(y,sol,mvi,i,"marg","Val") = DET_L.M(i);
                    LongActs(y,sol,mvi,i,"volum","Val") = (1+ScWDem(i)*Sum((e,s),ScDem_DET(e,s))/(card(e)*card(s)))*Lmaxp_DET(i)*DET_L.L(i);
                    Costs(y,sol,mvi,"Total","Val") = DET_TCOST.L;
                    Costs(y,sol,mvi,"Long","Val") = SUM(I, C1_DET(I)*DET_L.L(I));
                    Costs(y,sol,mvi,"Variance","Val") = DET_VCOST.L;
                    Costs(y,sol,mvi,"SolStat","Val")= TWOSTAGE_DETNE.SOLVESTAT;
                    Costs(y,sol,mvi,"ModStat","Val") = TWOSTAGE_DETNE.MODELSTAT;
                    Costs(y,sol,mvi,"ItsUsd","Val") = TWOSTAGE_DETNE.ITERUSD;
                    Costs(y,sol,mvi,"NumEqu","Val") = TWOSTAGE_DETNE.NUMEQU;
                    Costs(y,sol,mvi,"NumVar","Val") = TWOSTAGE_DETNE.NUMVAR;
                    Costs(y,sol,mvi,"SolTime","Val") = TWOSTAGE_DETNE.RESUSD;

                    LevelData(y,sol,mvi,"Rank","val") = Rank;
                    LevelData(y,sol,mvi,"Level","val") = LEVEL;
                    LevelData(y,sol,mvi,"LBnd","val") = CurrLB;
                    LevelData(y,sol,mvi,"UBnd","val") = CurrUB;
                    LevelData(y,sol,mvi,"CurrV","val") = CurrV;
                    LevelData(y,sol,mvi,"ModStat","val") = TWOSTAGE_DETNE.MODELSTAT;
                    LevelData(y,sol,mvi,"SolStat","val") = TWOSTAGE_DETNE.SOLVESTAT;
                    LevelData(y,sol,mvi,"SolGen","val") = 4;

                    ObjVals(d) = DET_TCOST.L;
                    );
*                     end of loop to log solution
                 );
*                  end of loop over bounds

            if (LastBounds("max") gt LastBounds("min")+1,
*                We need to find objective function values for the intermediate values between the bounds
                 xLAST = LastBounds("Min")+1;
                 while(xLAST lt LastBounds("Max"),
*          *        Log the solution
                    NumSols = NumSols+1;
*                   set the variable value
                    DET_L.L(i)$(ord(i) eq LEVEL) = xLAST;

                    loop(sol$(ord(sol) eq NumSols),
                        LongActs(y,sol,mvi,i,"level","Val") = DET_L.L(i);
                        LongActs(y,sol,mvi,i,"cost","Val") = DET_L.L(i)*c1_DET(i);
*                        LongActs(y,sol,mvi,i,"marg","Val") = DET_L.M(i);
                        LongActs(y,sol,mvi,i,"volum","Val") = (1+ScWDem(i)*Sum((e,s),ScDem_DET(e,s))/(card(e)*card(s)))*Lmaxp_DET(i)*DET_L.L(i);
                        Costs(y,sol,mvi,"Total","Val") = (ObjVals("max")-ObjVals("min"))/(LastBounds("max")-LastBounds("min"))*(xLAST - LastBounds("min")) + ObjVals("min");
*                        Costs(y,sol,mvi,"Long","Val") = SUM(I, C1_DET(I)*DET_L.L(I));
*                        Costs(y,sol,mvi,"Variance","Val") = DET_VCOST.L;
                        Costs(y,sol,mvi,"SolStat","Val")= TWOSTAGE_DETNE.SOLVESTAT;
                        Costs(y,sol,mvi,"ModStat","Val") = TWOSTAGE_DETNE.MODELSTAT;
*                        Costs(y,sol,mvi,"ItsUsd","Val") = TWOSTAGE_DETNE.ITERUSD;
*                        Costs(y,sol,mvi,"NumEqu","Val") = TWOSTAGE_DETNE.NUMEQU;
*                        Costs(y,sol,mvi,"NumVar","Val") = TWOSTAGE_DETNE.NUMVAR;
*                        Costs(y,sol,mvi,"SolTime","Val") = TWOSTAGE_DETNE.RESUSD;

                        LevelData(y,sol,mvi,"Rank","val") = Rank;
                        LevelData(y,sol,mvi,"Level","val") = LEVEL;
                        LevelData(y,sol,mvi,"LBnd","val") = CurrLB;
                        LevelData(y,sol,mvi,"UBnd","val") = CurrUB;
                        LevelData(y,sol,mvi,"CurrV","val") = xLAST;
                        LevelData(y,sol,mvi,"ModStat","val") = TWOSTAGE_DETNE.MODELSTAT;
                        LevelData(y,sol,mvi,"SolStat","val") = TWOSTAGE_DETNE.SOLVESTAT;
                        LevelData(y,sol,mvi,"SolGen","val") = 4.1;
                        );
*                    increment
                     xLAST = xLAST+1;
                     );
*                    end of while through last decision variable values inbetween bounds
                 );

*           %increment so we are finished with this level
            loop(i$(ord(i) eq LEVEL),
                 xCurr(i) = LastBounds("Max")+1;
                 xRange(i) = LastBounds("Max") - LastBounds("Min") + 1;
                 xCount(i) = xRange(i)+1;
                 );
     else
*       At an intermediary level
*       Set the current (soon to be prior) level to be fixed
        vFixedCurr(i)$(ord(i) eq level) = 1;
*       Drop a level.
        Rank = Rank+1;
        Level = sum(i$(ord(i) eq Rank),RankLevel(i));
*       level = smin(i$(vFixedCurr(i) eq 0),IndCount(i));

        if (sum(i$(ord(i) eq Level), SkipFindBounds(i)) eq 0,
*          Solve for the bounds at this level given the
*          the variable values specified at prior levels
*
*          Set up the objective function -- i.e., the decision variable
           LToUse(i) = 0;
           LToUse(i)$(ord(i) eq level) = 1;
*          Loop over the min and max directions
           Loop (d,

*      *      Set up limits on long-term variables
              DET_L.UP(i) = Lmaxunits(I);
              DET_L.LO(i) = 0;

*      *      Fixed variables are constrained to their values
              DET_L.FX(i)$(vFIXEDCurr(i)) = xCurr(i);

*      *      Initialize solution start point
              DET_L.L(I) = DET_L.UP(I);
              DET_SLACK.L(S,E) = 0;

              If (ord(d) eq 1,
*      *        Minimizing, solve for lower bound
                SOLVE TWOSTAGE_DETNE USING MINLP MINIMIZING L_VAL;
                );

              If (ord(d) eq 2,
*      *        Maximizing, solve for the upper bound
                SOLVE TWOSTAGE_DETNE USING MINLP MAXIMIZING L_VAL;
                );

              NumSolvs = NumSolvs+1;

*             %Set bounds at this level
              CurrBounds(d,i)$(ord(i) eq level) = DET_L.L(i);

              if ((TWOSTAGE_DETNE.SOLVESTAT ne 1),
                 DISPLAY TWOSTAGE_DETNE.SOLVESTAT, TWOSTAGE_DETNE.MODELSTAT;
                 Execute_Unload 'matsol.gdx';
                 );
              );
*               end of d loop
           );
*             end of if need to find bounds

*        Initialize variable values at this level
         loop(i$(ord(i) eq LEVEL),
             xCurr(i) = CurrBounds("min",i);
             xCount(i) = 1;
             xRange(i) = CurrBounds("max",i)-CurrBounds("min",i)+1;
             WorkBounds(d,i) = CurrBounds(d,i);
             PrevBounds(d,i2) = CurrBounds(d,i2);
             );
         );
*        end of major if

         while (sum(i$(ord(i) eq level),xCount(i) gt xRange(i)) and (level ne FirstX),
*          We finished enumerating at an inner level; Set this level back to unfixed, move to the next, prior, outer level,
*          determine whether we can skip solving for bounds at the inner level, and increment the counter for that outer level
           InnerLevel = LEVEL;
*          Set the level back to unfixed
           vFixedCurr(i)$(ord(i) eq level) = 0;
*          Turn off skipping at all deeper levels
*           SkipFindBounds(i)$(ord(i) eq level) = 0;
           SkipFindBounds(i)$(RankRange(i) ge Rank) = 0;
*          Move to the prior outer level
           Rank = Rank-1;
           Level = sum(i$(ord(i) eq Rank),RankLevel(i));

*          Determine whether we can skip solving for bounds at the inner level. Use loop over i2 to control for inner level
           loop(i2$(ord(i2) eq InnerLevel),
              if ((sum(i$(ord(i) eq LEVEL),xCount(i)) gt 1) and (SkipFindBounds(i2) eq 0) and (sum(d,PrevBounds(d,i2) - CurrBounds(d,i2)) eq 0),
*                 Current and prior bounds at the inner level are the same. Therefore, bounds for all other
*                 enumerations at the inner level will also be the same. No need to search
                  SkipFindBounds(i2) = 1;
               else
*   *             Store the current bounds and use in the comparison at the next iteration
                  PrevBounds(d,i2) = CurrBounds(d,i2);
                  );
               );

*          Increment the counter for the outer level - proceeds according to the bounds in a min, max, min+1, max-1, min+2, max-2, ... order
*          to progressively ratchet inwards in hopes of identifying a range of enumerated values that have the same
*          bounds on the next inner level and will save us the effort of having to
*          resolve for bounds at the inner level
*            level = smax(i$((lFixed(i) eq 0) and (ord(i) lt level)),IndCount(i));
           loop(i$(ord(i) eq Level),
              if (xCurr(i) eq WorkBounds("min",i),
*                jump to max bound
                 xCurr(i) = WorkBounds("max",i);
              else
*                contract the bounds inward by one
                 WorkBounds(d,i) = WorkBounds(d,i) + Adjust(d);
                 xCurr(i) = WorkBounds("min",i);
                 );

              xCount(i) = xCount(i) + 1;
              );
*           xCurr(i)$(ord(i) eq level) = xCurr(i)+1;
           );
*           end of while at the end of enumerating for a level
    );
**** end of grand while

    );
*end of mean-variance tradeoff curve point loop - mvi
    );
*** end of demand year loop

*Output input scalars*

LongActs(y,sol,mvi,i,ModDat,Dum)$((ord(sol) le NumSols) and YtoUse(y)) = LongActs(y,sol,mvi,i,ModDat,Dum) + EPS;
Costs(y,sol,mvi,CostTyp,Dum)$((ord(sol) le NumSols) and YtoUse(y)) =   Costs(y,sol,mvi,CostTyp,Dum) + EPS;
LevelData(y,sol,mvi,Levs,Dum)$((ord(sol) le NumSols) and YtoUse(y)) =   LevelData(y,sol,mvi,Levs,Dum) + EPS;

XCURR(i)$(XCURR(i) gt Bounds("max",i)) = Bounds("Max",i);

CurrPosAlt = sum(i$(ord(i) ge RankFirstUnfixed),sum(i2$(ord(i) eq RankRange(i2)),(xCurr(i2) - Bounds("min",i2)))*
                 prod(i2$(RankRange(i2) gt ord(i)),(Bounds("max",i2)-Bounds("min",i2)+1)) )+1;
FractAlts = CurrPosAlt/MaxPosAlt;
SearchEfficiency = NumSolvs/CurrPosAlt;

Set scals Set whose elements are model scalars /tcap, disttype,r,sdwidth,td,numyrs,numscens, numltacts, numcsts, nummvpts, gamma, fopt/;

Parameter ScalVals(scals);

ScalVals("tcap") = TCAP;
ScalVals("disttype") = DISTTYPE;
ScalVals("r") = R;
ScalVals("sdwidth") = SDWIDTH;
ScalVals("td") = TD;
ScalVals("numyrs") = Sum(y,YtoUse(y));
ScalVals("numscens") = Card(sc);
*ScalVals("numscits") = 3 + Sum(ro$(NumScens(ro) gt 1), 1);
ScalVals("numltacts") = Card(i);
ScalVals("numcsts") = Card(CostTyp);
*ScalVals("CumScens") = Sum(ro$(NumScens(ro) gt 1), NumScens(ro));
ScalVals("nummvpts") = Card(mvi);
ScalVals("gamma") = GAMMA;
ScalVals("fopt") = FOPT;

LToUse(i) = LToUse(i) + EPS;
LFixedVal(i) = LFixedVal(i) + EPS;

DISPLAY NumSols, NumSolvs, LToUse, Costs, LongActs, LevelData;

** PASS Results back to MATLAB
Execute_Unload 'AmmanJordanOptNear.gdx';

